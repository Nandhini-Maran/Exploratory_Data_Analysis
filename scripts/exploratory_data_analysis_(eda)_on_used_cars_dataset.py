# -*- coding: utf-8 -*-
"""Exploratory_Data_Analysis_(EDA)_on_Used_cars_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1blMAqQaYrwg9PWc2uzT4V7J1-0fP3yUX

# **Exploratory Data Analysis (EDA) of Used Cars Dataset**

#  1. Introduction

This notebook performs Exploratory Data Analysis (EDA) on a dataset containing used car details. The goal is to understand the data, clean it, handle missing values, and extract useful insights.

# 2. Loading Required Libraries
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import date
import warnings
warnings.filterwarnings('ignore')

"""# 3. Loading the Dataset"""

data = pd.read_csv("used_cars_data.csv")

"""# 4. Initial Exploration"""

#first 5 rows
data.head()

#last 5 rows
data.tail()

#shape of the dataset
data.shape

#Displays data types and memory usage.
data.info()

#Counts unique values per column
data.nunique()

# Identifying duplicate values
data.duplicated().sum()

#Identifies missing values
data.isnull().sum()

#missing values in columns
(data.isnull().sum()/(len(data)))*100

"""#5. Handling Missing Data"""

data['Mileage'] = data['Mileage'].str.extract(r'(\d+\.\d+)').astype(float)
data['Engine'] = data['Engine'].str.extract(r'(\d+)').astype(float)
data['Power'] = data['Power'].str.extract(r'(\d+\.\d+)').astype(float)

data['Mileage'].fillna(data['Mileage'].median(), inplace=True)
data['Engine'].fillna(data['Engine'].median(), inplace=True)
data['Power'].fillna(data['Power'].median(), inplace=True)
data['Seats'].fillna(data['Seats'].mode()[0], inplace=True)

# Remove S.No. column from data
data = data.drop(['S.No.'], axis = 1)
data.drop(columns=['New_Price'], inplace=True)  # Dropping due to excessive missing values
data.dropna(subset=['Price'], inplace=True)  # Dropping rows where price is missing
data.info()

"""# **6. Feature Engineering**

# Creating New Features
"""

date.today().year
data['Car_Age']=date.today().year-data['Year']#Extracts Car_Age from Year.
data['Brand'] = data.Name.str.split().str.get(0)
data['Model'] = data.Name.str.split().str.get(1) + data.Name.str.split().str.get(2)#Extracts Brand and Model from the Name column

data[['Name','Brand','Model','Car_Age']]

"""#Standardizing Brand Names"""

print(data.Brand.unique())
print(data.Brand.nunique())

searchfor = ['Isuzu' ,'ISUZU','Mini','Land']  #Ensures consistent brand naming
data[data.Brand.str.contains('|'.join(searchfor))].head(5)

data["Brand"].replace({"ISUZU": "Isuzu", "Mini": "Mini Cooper","Land":"Land Rover"}, inplace=True)

"""# **7. Statistical Summary**"""

data.describe().T #Provides statistical summaries of numerical and categorical features

data.describe(include='all').T

"""# separating numeric and categorical columns"""

cat_cols=data.select_dtypes(include=['object']).columns
num_cols = data.select_dtypes(include=np.number).columns.tolist()
print("Categorical Variables:")
print(cat_cols)
print("Numerical Variables:")
print(num_cols)

"""# **8. Identifying Outliers**"""

for col in num_cols:
    plt.figure(figsize=(8, 4))
    sns.boxplot(x=data[col])
    plt.title(f'Boxplot of {col}')
    plt.show()

"""#Outlier Removal using IQR"""

# Outlier Detection using IQR
def remove_outliers(df, column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    return df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]

outlier_columns = ['Price', 'Kilometers_Driven', 'Mileage', 'Engine', 'Power']
for col in outlier_columns:
    data = remove_outliers(data, col)

plt.figure(figsize=(8, 4))
sns.boxplot(x=data['Price']) # Corrected indentation and using data['Price']
plt.title('price')
plt.show()

"""# **9. Data Visualization**

# Skewness Check
"""

# Check skewness for numerical features
if len(num_cols) % 2 != 0:
    num_cols = num_cols[:-1]

for i in range(0, len(num_cols), 2):
    col1, col2 = num_cols[i], num_cols[i + 1]
    skew1 = round(data[col1].skew(), 2)
    skew2 = round(data[col2].skew(), 2)
    print(f"Feature: {col1}, Skewness: {skew1}")
    print(f"Feature: {col2}, Skewness: {skew2}")
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))
    sns.histplot(data[col1], bins=30, kde=True, color='blue', ax=axes[0])
    axes[0].set_title(f'Histogram of {col1} (Skewness: {skew1})')
    sns.histplot(data[col2], bins=30, kde=True, color='red', ax=axes[1])
    axes[1].set_title(f'Histogram of {col2} (Skewness: {skew2})')
    plt.show()

"""# Log Transformation"""

# Function for log transformation of the column
def log_transform(data,col):
    for colname in col:
        if (data[colname] == 1.0).all():
            data[colname + '_log'] = np.log(data[colname]+1)
        else:
            data[colname + '_log'] = np.log(data[colname])
    data.info()

log_transform(data,['Price','Kilometers_Driven'])

#Applies log transformation to Price for better normality.
sns.distplot(data["Price_log"], axlabel="Price");
sns.distplot(data["Kilometers_Driven_log"], axlabel="Kilometers_Driven");

"""# Categorical Data Visualization"""

fig, axes = plt.subplots(3, 2, figsize = (18, 18))
fig.suptitle('Bar plot for all categorical variables in the dataset')
sns.countplot(ax = axes[0, 0], x = 'Fuel_Type', data = data, color = 'blue',
              order = data['Fuel_Type'].value_counts().index);
sns.countplot(ax = axes[0, 1], x = 'Transmission', data = data, color = 'blue',
              order = data['Transmission'].value_counts().index);
sns.countplot(ax = axes[1, 0], x = 'Owner_Type', data = data, color = 'blue',
              order = data['Owner_Type'].value_counts().index);
sns.countplot(ax = axes[1, 1], x = 'Location', data = data, color = 'blue',
              order = data['Location'].value_counts().index);
sns.countplot(ax = axes[2, 0], x = 'Brand', data = data, color = 'blue',
              order = data['Brand'].head(20).value_counts().index);
sns.countplot(ax = axes[2, 1], x = 'Model', data = data, color = 'blue',
              order = data['Model'].head(20).value_counts().index);
axes[1][1].tick_params(labelrotation=45);
axes[2][0].tick_params(labelrotation=90);
axes[2][1].tick_params(labelrotation=90);

"""# pairplot for numeric features"""

plt.figure(figsize=(13,17))
sns.pairplot(data=data.drop(['Kilometers_Driven','Price'],axis=1))
plt.show()

"""# categorical features vs Price"""

fig, axarr = plt.subplots(4, 2, figsize=(12, 18))
data.groupby('Location')['Price_log'].mean().sort_values(ascending=False).plot.bar(ax=axarr[0][0], fontsize=12)
axarr[0][0].set_title("Location Vs Price", fontsize=18)
data.groupby('Transmission')['Price_log'].mean().sort_values(ascending=False).plot.bar(ax=axarr[0][1], fontsize=12)
axarr[0][1].set_title("Transmission Vs Price", fontsize=18)
data.groupby('Fuel_Type')['Price_log'].mean().sort_values(ascending=False).plot.bar(ax=axarr[1][0], fontsize=12)
axarr[1][0].set_title("Fuel_Type Vs Price", fontsize=18)
data.groupby('Owner_Type')['Price_log'].mean().sort_values(ascending=False).plot.bar(ax=axarr[1][1], fontsize=12)
axarr[1][1].set_title("Owner_Type Vs Price", fontsize=18)
data.groupby('Brand')['Price_log'].mean().sort_values(ascending=False).head(10).plot.bar(ax=axarr[2][0], fontsize=12)
axarr[2][0].set_title("Brand Vs Price", fontsize=18)
data.groupby('Model')['Price_log'].mean().sort_values(ascending=False).head(10).plot.bar(ax=axarr[2][1], fontsize=12)
axarr[2][1].set_title("Model Vs Price", fontsize=18)
data.groupby('Seats')['Price_log'].mean().sort_values(ascending=False).plot.bar(ax=axarr[3][0], fontsize=12)
axarr[3][0].set_title("Seats Vs Price", fontsize=18)

plt.subplots_adjust(hspace=1.0)
plt.subplots_adjust(wspace=.5)
sns.despine()

#Price vs Fuel Types
plt.figure(figsize=(10, 5))
sns.boxplot(x='Fuel_Type', y='Price_log', data=data)
plt.title('Price Variation Across Fuel Types')
plt.show()

# Transmission vs Price
plt.figure(figsize=(10, 5))
sns.boxplot(x='Transmission', y='Price_log', data=data)
plt.title('Price Variation Across Transmission Types')
plt.show()

# Owner Type Analysis
sns.countplot(x='Owner_Type', data=data, palette='pastel')
plt.title('Owner Type Distribution')
plt.show()

"""# Correlation Analysis"""

plt.figure(figsize=(12, 7))
sns.heatmap(data.drop(['Kilometers_Driven',  'Price'],axis=1).corr(numeric_only=True), annot = True, vmin = -1, vmax = 1)
plt.show()

"""# **10. Key Findings**

#1.Missing Values: Mileage, Engine, Power, and Seats had missing values, which were handled appropriately.

#2. Feature Engineering: Extracted Car_Age, Brand, and Model from existing data.

#3. Outliers: Removed extreme values from Price, Kilometers_Driven, and other numerical features.

#4. Distribution Analysis:

   #For skewed distributiontion  applied log transformation.
   
   #Most of the people prefer first hand ownership

   #manual cars are more prefered over other type

   #electric cars price is compared to other types  

   #Fuel_Type, Transmission, and Owner_Type impact Price significantly.

#5. Correlation:

Engine and Power have a strong positive correlation.

Car_Age negatively impacts Price (older cars are cheaper).

# **11. Conclusion**

# This EDA provided valuable insights into the dataset, cleaned the data, handled missing values, and performed essential feature engineering. The next steps could involve predictive modeling for price estimation or further exploratory analysis on brand-wise car pricing trends.
"""